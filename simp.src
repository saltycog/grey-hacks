// command: simp
// Usage: simp [ip_address]:[port]
// Scans and executes exploits against a target


// --- Globals ---------------------------------------
TAB = char(9)

ip = null
port = null
verbose = false

metaxploit = null
crypto = null


// --- Attack Class ----------------------------------
Attack = {}
Attack.memory_address = null
Attack.buffer_overflow = null
Attack.details = null
Attack.handler = null
Attack.user = null

Attack.New = function(memory_address, attack_raw)
	attack_lines = attack_raw.split("\n")
	buffer_overflow_raw = attack_lines[0]
	requirements = attack_lines[1:]
	buffer_overflow = buffer_overflow_raw.matches("(?<=\<b\>)(.*)(?=\</b\>)").values[0]
	handler = metalib.overflow(memory_address, buffer_overflow, "password")
	user = infer_user(handler)

	self = new Attack
	self.memory_address = memory_address
	self.buffer_overflow = buffer_overflow
	self.requirements = requirements
	self.handler = handler
	self.user = user
	return self
end function

// Perform 
Attack.probe = function()
	metaxploit = get_metaxploit
	result = metalib.overflow(self.memory_address, self.buffer_overflow)
	return result
end function

// Execute attack based on handler
Attack.execute = function()
	if self.handler == null then
		return
	end if
	
	type = typeof(self.handler)
	if type == "shell" then 
		self.execute_shell_terminal(self.handler)
		exit
	end if
	
	if type == "computer" then
		self.execute_try_get_passwd(self.handler)
		exit
	end if

	if type == "file" then
		print("[ <color=#FF0000><b>No actions know yet for found file:</color> " + result.name + "</b> ]")
		exit
	end if

	// Number: Firewall disabled
	// Number: Change password

	print("[ <color=#FF0000><b>No actions yet for attack type:</color> " + type + "</b> ]")
	exit
end function



// Attempt to download passwd file from attack target.
Attack.execute_try_get_passwd = function(remote_computer = null)
	if remote_computer == null then remote_computer = self.handler
	remote_passwd = remote_computer.File("/etc/passwd")
	if remote_passwd != null and remote_passwd.has_permission("r") then
		local_path = current_path
		local_filename = "passwd_" + remote_computer.get_name
		local_passwd = local_computer.File(local_path + "/" + local_filename)
		if local_passwd == null then 
			local_computer.touch(local_path, local_filename)
			local_passwd = local_computer.File(local_path + "/" + local_filename)
		end if
		local_passwd.set_content(remote_passwd.get_content)
		print("<b>Downloaded to: " + local_path + "/" + local_filename)
		// TODO: Decipher root password
	end if
	exit
end function

// "Corrupt" logs on attack target.
Attack.corrupt_logs = function(handler = null)
	if handler == null then handler = self.handler
	if typeof(handler) == "shell" then remote_computer = remote_shell.host_computer
	if typeof(handler) == "computer" then remote_computer = handler
	syslog = remote_computer.File("/var/system.log")
	syslog.delete
	remote_computer.touch("home/guest", "system.log")
	syslog = remote_computer.File("/home/guest/system.log")
	syslog.set_content("Your {}'s have been thoroughly salted!")
	syslog.chmod("u-rwx")
	syslog.chmod("g-rwx")
	syslog.chmod("o-rwx")
	syslog.set_owner("root")
	syslog.set_group("root")
	syslog.move("/var", "system.log")
end function

Attack.display_attack_options = function()
	print_header("OPTIONS:")
	handler_type = self.handler
	if typeof(handler_type) == "shell" then self.display_shell_options
	if typeof(handler_type) == "computer" then self.display_computer_options
end function

Attack.display_shell_options = function()
	should_enter = confirmation_prompt("<b>Enter shell as " + self.user + "?</b> ")
	if should_enter then 
		self.execute_shell_terminal
	end if
end function

// Connect to attack target and start a terminal session.
// Clears logs in advance if root obtained.
Attack.execute_shell_terminal = function(remote_shell = null)
	if remote_shell == null then remote_shell = self.handler
	print_header()
	if self.user == "root" then 
		print("Corrupted target logs")
		self.corrupt_logs(remote_shell)
	end if
	print("Connecting...")
	remote_shell.start_terminal
end function

Attack.display_computer_options = function()
	
	print(" <b>[0]</b> Try to obtain /etc/passwd")
	print
	choice = user_input("<b>Select options:<b> ")
	if choice == "0" then self.obtain_passwd_file
end function

Attack.obtain_passwd_file = function(remote_computer = null)
	if self.user == "root" then self.corrupt_logs
	if remote_computer == null then remote_computer = self.handler
	remote_passwd = remote_computer.File("/etc/passwd")
	if remote_passwd != null and remote_passwd.has_permission("r") then
		passwd_contents = remote_passwd.get_content
		print
		print("<b>passwd contents:</b>")
		passwd_lines = passwd_contents.split("\n")
		i = 0
		for line in passwd_lines
			if line.trim == "" then continue
			print(" <b>[" + i + "]</b> " + line)
			i = i + 1
		end for
		print
		choice = user_input("<b>Decipher which line?</b> ").to_int
		if choice != null then
			line_tokens = passwd_lines[choice].split(":")
			user = line_tokens[0]
			password = crack(line_tokens[1])
			print("<b>User:</b> " + user)
			print("<b>Password:</b> " + password)
		end if
	end if
end function


// --- AttackTree Class ------------------------------
AttackTree = {}
AttackTree.attacks = null

AttackTree.New = function(scan)
	index = 0
	attacks = []
	i = 0
	for memory_address in scan
		attacks_raw =  metaxploit.scan_address(metalib, memory_address)
		attacks_raw = attacks_raw.replace("decompiling source...\nsearching unsecure values...\n","")
		attacks_raw = attacks_raw.split("\n\n")
		for attack_raw in attacks_raw
			if attack_raw != "" then
				print("<b>[" + i + "]</b>")
				attack = Attack.New(memory_address, attack_raw)
				attacks.push(attack)
				print("<b> - - - </b>")
			end if
			i = i + 1
		end for
	end for

	self = new AttackTree
	self.attacks = attacks
	return self
end function

AttackTree.display_attacks = function()
	reqs_label = ""
	if globals.verbose then reqs_label = "REQUIREMENTS"
	if globals.verbose != true then clear_screen

	print("-" * 55)
	print(" <b>ID   USER      HANDLER            " + reqs_label + "</b>")
	print("-" * 55)
	
	i = 0
	for attack in self.attacks
		if attack.handler == null and globals.verbose != true then 
			i = i + 1
			continue
		end if

		if attack.user == "root" then
			color = "<color=#00FF00>"
		else if attack.user == "guest" then
			color = "<color=#FFFFFF>"
		else if attack.user == "???" then
			color = "<color=#303030>"
		else
			color = "<color=#FFFF00>"
		end if
		
		requirements = ""
		if attack.handler == null then 
			handler = "???"
			requirements = "NEED (x" + attack.requirements.len + ")"
		else if typeof(attack.handler) == "file" then
			handler = typeof(attack.handler) + ": " + attack.handler.path
		else if typeof(attack.handler) == "number" then
			handler = "#" + attack.handler
		else
			handler = typeof(attack.handler)
		end if
		line = " " * 70
		line = line.insert(0, color)
		line = line.insert(16, "<b>[" + i + "]</b>")
		line = line.insert(28, attack.user)
		line = line.insert(39, handler)
		line = line.insert(60, requirements)
		line = line.insert(70, "</color>")
		print(line)
		i = i + 1
	end for
	print
	
	selection = user_input("<b>Select attack:</b> ").to_int
	if selection < self.attacks.len then 
		self.attacks[selection].display_attack_options
	else

	end if
end function


// --- Global Functions ------------------------------
local_computer = get_shell.host_computer

print_header = function(label = null, divider_length = 55)
	divider = "-" * divider_length	
	print("\n<b>" + divider + "</b>")
	if label != null then print("<b>" + label + "</b>")
end function

// Prompt user for input.
// prompt: Prompt to display.
// char: First character of response that will return true (default 'y')
confirmation_prompt = function(prompt, char = "y")
	choice = user_input(prompt)
	if choice.lower.indexOf(char) == 0 then return true
end function

exit_prompt = function()
	choice = user_input("<b>Exit simp?</b> ")
	if confirmation_prompt(choice) then exit()
end function

get_metaxploit = function()
	if globals.metaxploit == null then
		metaxploit = include_lib("/lib/metaxploit.so")
		if not metaxploit then metaxploit = include_lib(current_path + "/metaxploit.so")
		if not metaxploit then 
			exit("<color=#FF0000>Error: Can't find metaxploit library in the /lib path or the current folder</color>")
		end if
		globals.metaxploit = metaxploit
	end if
	return globals.metaxploit
end function

get_crypto = function()
	if globals.crypto == null then
		crypto = include_lib("/lib/crypto.so")
		if not crypto then crypto = include_lib(current_path + "/crypto.so")
		if not crypto then 
			exit("<color=#FF0000>Error: Can't find crypto library in the /lib path or the current folder</color>")
		end if
		globals.crypto = crypto
	end if
	return globals.crypto
end function

get_cached_scan = function(cached_scan_filename)
	path = "/" + active_user + "/Scans"
	if active_user != "root" then path = "/home" + path
	local_computer = get_shell.host_computer
	cached_scan_file = local_computer.File(path + "/" + cached_scan_filename)
	if cached_scan_file == null then
		local_computer.touch(path, cached_scan_filename)
		cached_scan_file = local_computer.File(path + "/" + cached_scan_filename)
		cached_scan_file.chmod("o-rwx")
		cached_scan_file.chmod("g-rwx")
		if active_user == "root" then cached_scan_file.chmod("u-rwx")
	end if
	return cached_scan_file
end function

crawl_to_dir = function(dir, file_handler)
	file = file_handler
	while file.path != "/"
		file = file.parent
	end while
	for folder in file.get_folders
		if folder.path == dir then return folder
	end for
	return null
end function

infer_user = function(handler)
	if typeof(handler) == "shell" or typeof(handler) == "ftpshell" then
		handler = handler.host_computer.File("/")
	end if

	if typeof(handler) == "computer" then
		handler = handler.File("/")
	end if

	if typeof(handler) == "file" then
		root_dir = crawl_to_dir("/root", handler)
		if root_dir != null and root_dir.has_permission("w") then return "root"
		home_dir = crawl_to_dir("/home", handler)
		if home_dir != null then
			for user in home_dir.get_folders
				if user.name == "guest" then 
					guest = user
					continue
				end if
				if user.has_permission("w") then return user.name
			end for
			if guest.has_permission("w") then return "guest"
		end if
	end if
	
	return "???"
end function

get_user_home = function()
	if active_user == "root" then return "/root"
	return "/home/" + active_user
end function

get_hashes_file = function()
	config_dir = get_user_home + "/Config"
	computer = get_shell.host_computer
	hashes_file = computer.File(config_dir + "/Hashes.txt")
	if hashes_file == null then
		computer.touch(config_dir, "Hashes.txt")
		hashes_file = computer.File(config_dir + "/Hashes.txt")
		hashes_file.chmod("o-rwx")
		hashes_file.chmod("g-rwx")
		if active_user == "root" then hashes_file.chmod("u-rwx")
	end if
    return hashes_file
end function

get_cached_hash_value = function(hash)
    hashes_file = get_hashes_file
    lines = hashes_file.get_content.split("\n")
    for line in lines
        line_parts = line.split("=")
        if line_parts[0] == hash then return line_parts[1]
    end for
    return null
end function

save_hash_to_cache = function(hash, hash_value)
    hashes_file = get_hashes_file
    hash_line = hash + "=" + hash_value
    hashes_file_content = hashes_file.get_content
    if hashes_file_content != "" then hashes_file_content = hashes_file_content + NEWLINE
    hashes_file.set_content(hashes_file_content + hash_line)
end function

get_crypto = function()
	if globals.crypto == null then
		crypto = include_lib("/lib/crypto.so")
		if not crypto then crypto = include_lib(current_path + "/crypto.so")
		if not crypto then 
			exit("<color=#FF0000>Error: Can't find crypto library in the /lib path or the current folder</color>")
		end if
		globals.crypto = crypto
	end if
	return globals.crypto
end function

crack = function(hash)
    if hash.indexOf(":") != null then hash = hash.split(":")[1]
    result = get_cached_hash_value(hash)
    if result == null then 
        result = get_crypto.decipher(hash)
        save_hash_to_cache(hash, result)
    end if
    return result
end function


// --- MAIN ------------------------------------------
if params.len == 0 or params.len > 2 or params[0] == "-h" or params[0] == "--help" then 
	exit("<b>Usage: simp (-v) [ip_address]:[port]</b>")
end if

if params.indexOf("-v") != null or params.indexOf("--verbose") then verbose = true

address_tokens = params[params.len - 1].split(":")
ip = address_tokens[0]
port = address_tokens[1].to_int

// Load library
metaxploit = get_metaxploit
net_session = metaxploit.net_use(ip, port)
if not net_session then 
	exit("<color=#FF0000>Error: Unable to connect to net session.</color>")
end if

// Check for online admins
if net_session.is_root_active_user then
	exit_prompt("<b><color=#FFAA00>An admin is online. Abort?</color></b> ")
end if

metalib = net_session.dump_lib
cached_scan_filename = metalib.lib_name.replace("\.so", "") + "-" + metalib.version + ".scan"
cached_scan = get_cached_scan(cached_scan_filename)
if cached_scan.get_content == "" then
	print_header("<color=#00FF00>SCANNING:</color> " + metalib.lib_name + " v" + metalib.version)
	scan = metaxploit.scan(metalib)
	cached_scan.set_content(scan.join(","))
else
	print_header("<color=#00FF00>USING CACHED SCAN:</color> " + cached_scan_filename)
	scan = cached_scan.get_content.split(",")
end if

attack_tree = AttackTree.New(scan)
attack_tree.display_attacks